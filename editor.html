<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>書き順エディタ</title>
<style>
  @font-face {
    font-family: 'Klee One';
    src: url('fonts/KleeOne-SemiBold.ttf') format('truetype');
    font-weight: 600;
    font-display: swap;
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  body { display:flex; flex-direction:column; align-items:center; min-height:100vh; background:#f0f0f0; font-family:sans-serif; padding:20px; }

  /* ヘッダー: 漢字入力 + 画数表示 */
  .header { display:flex; align-items:center; gap:16px; margin-bottom:16px; flex-wrap:wrap; justify-content:center; }
  #kanjiInput {
    font-size:32px; width:64px; text-align:center;
    border:2px solid #ddd; border-radius:8px; padding:4px;
    font-family:'Klee One', serif;
  }
  #strokeCount { font-size:16px; color:#666; font-weight:700; }

  /* キャンバスエリア */
  .canvas-area { position:relative; width:300px; height:300px; background:#fff; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.1); overflow:hidden; }

  /* フォント参照文字（薄く表示） */
  .ref-char { position:absolute; top:0; left:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center;
    font-family:'Klee One', serif; font-size:250px; font-weight:600; color:rgba(200,200,200,0.4);
    line-height:1; user-select:none; pointer-events:none; }

  /* SVGを上に重ねる */
  .stroke-svg { position:absolute; top:0; left:0; width:100%; height:100%; }

  /* ボタン */
  .controls { margin-top:12px; display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
  button { padding:10px 18px; font-size:14px; border:none; border-radius:8px; cursor:pointer; background:#FF8E53; color:#fff; font-weight:700; }
  button:active { background:#e07040; }
  button.secondary { background:#aaa; }
  button.danger { background:#e53935; }

  /* JSON出力エリア */
  #outputArea { display:none; margin-top:16px; width:100%; max-width:400px; }
  #jsonOutput { width:100%; height:160px; font-size:12px; font-family:monospace; border:1px solid #ddd; border-radius:8px; padding:8px; resize:vertical; }
  .output-controls { margin-top:8px; display:flex; gap:12px; justify-content:center; }

  /* ヒント */
  .toggle-label { margin-top:8px; font-size:14px; color:#666; display:flex; align-items:center; gap:8px; }
  .hint { margin-top:16px; color:#888; font-size:13px; text-align:center; line-height:1.8; max-width:340px; }
</style>
</head>
<body>

<div class="header">
  <input id="kanjiInput" type="text" maxlength="1" placeholder="字">
  <span id="strokeCount">タップして点を配置</span>
</div>

<div class="canvas-area" id="canvasArea">
  <!-- フォント参照文字 -->
  <div class="ref-char" id="refChar"></div>

  <!-- 描画SVG -->
  <svg id="drawSvg" class="stroke-svg" viewBox="0 0 300 300" style="touch-action:manipulation;">
    <!-- ガイド十字線 -->
    <line x1="150" y1="0" x2="150" y2="300" stroke="#eee" stroke-width="0.5" stroke-dasharray="6,6"/>
    <line x1="0" y1="150" x2="300" y2="150" stroke="#eee" stroke-width="0.5" stroke-dasharray="6,6"/>
  </svg>
</div>

<div class="controls">
  <button onclick="confirmStroke()">画を確定</button>
  <button class="secondary" onclick="undoPoint()">点を消す</button>
  <button class="secondary" onclick="undoStroke()">画を消す</button>
  <button class="danger" onclick="clearAll()">全消し</button>
</div>
<div class="controls">
  <button onclick="exportJSON()">JSON出力</button>
  <button class="secondary" onclick="togglePoints()">参照を表示</button>
</div>

<label class="toggle-label">
  <input type="checkbox" id="centerSnap" checked onchange="drawCenterLines()"> 中心スナップ
</label>

<div id="outputArea">
  <textarea id="jsonOutput" readonly></textarea>
  <div class="output-controls">
    <button onclick="copyToClipboard()">コピー</button>
  </div>
</div>

<div class="hint">
  タップで点を配置 → 「画を確定」で滑らかな曲線を生成<br>
  直線の画は2点、曲線は3点以上で
</div>

<script>
// --- 定数 ---
const STROKE_COLORS = [
  '#e53935', '#1e88e5', '#43a047', '#fb8c00',
  '#8e24aa', '#00acc1', '#6d4c41', '#546e7a'
];
const SVG_NS = 'http://www.w3.org/2000/svg';

// --- 状態 ---
let tapPoints = [];         // 現在の画の配置点 [{x, y}, ...]
let splineStrokes = [];     // 確定済み [{points: [{x,y}...], path: "M...C..."}]
let dragIdx = -1;              // ドラッグ中の点インデックス (-1=なし)
let isDragging = false;        // ドラッグ中フラグ
let lastSnappedPos = null;     // スナップカーソルが表示していた位置（指離し時にこの位置を使う）

// --- DOM参照 ---
const svg = document.getElementById('drawSvg');
const kanjiInput = document.getElementById('kanjiInput');
const refChar = document.getElementById('refChar');
const strokeCountEl = document.getElementById('strokeCount');

// 中心線表示グループ（タップ点の下に描画）
const centerLineGroup = document.createElementNS(SVG_NS, 'g');
centerLineGroup.id = 'centerLines';
centerLineGroup.setAttribute('pointer-events', 'none');
svg.appendChild(centerLineGroup);

// タップ点・曲線プレビュー用グループ
const tapGroup = document.createElementNS(SVG_NS, 'g');
tapGroup.id = 'tapGroup';
svg.appendChild(tapGroup);

// スナップカーソル（タップ前にスナップ先をプレビュー）
const snapCursorGroup = document.createElementNS(SVG_NS, 'g');
snapCursorGroup.id = 'snapCursor';
snapCursorGroup.style.display = 'none';
snapCursorGroup.setAttribute('pointer-events', 'none');
svg.appendChild(snapCursorGroup);
const scH = document.createElementNS(SVG_NS, 'line');
scH.setAttribute('stroke', '#FF8E53');
scH.setAttribute('stroke-width', '1.5');
scH.setAttribute('stroke-opacity', '0.8');
const scV = document.createElementNS(SVG_NS, 'line');
scV.setAttribute('stroke', '#FF8E53');
scV.setAttribute('stroke-width', '1.5');
scV.setAttribute('stroke-opacity', '0.8');
const scDot = document.createElementNS(SVG_NS, 'circle');
scDot.setAttribute('r', '3');
scDot.setAttribute('fill', '#FF8E53');
scDot.setAttribute('fill-opacity', '0.8');
snapCursorGroup.appendChild(scH);
snapCursorGroup.appendChild(scV);
snapCursorGroup.appendChild(scDot);

function showSnapCursor(x, y) {
  scH.setAttribute('x1', x - 10); scH.setAttribute('y1', y);
  scH.setAttribute('x2', x + 10); scH.setAttribute('y2', y);
  scV.setAttribute('x1', x); scV.setAttribute('y1', y - 10);
  scV.setAttribute('x2', x); scV.setAttribute('y2', y + 10);
  scDot.setAttribute('cx', x); scDot.setAttribute('cy', y);
  snapCursorGroup.style.display = '';
}
function hideSnapCursor() { snapCursorGroup.style.display = 'none'; }

// 中心線キャッシュ
let cachedCenterKanji = '';
let cachedCenterPoints = [];  // スナップ用: [{x, y}, ...]
let cachedCenterLines = [];   // 描画用: [[ {x,y}, ... ], ...]

// ===========================
// 漢字入力 → フォントオーバーレイ
// ===========================
kanjiInput.addEventListener('input', function() {
  if (this.value.length > 1) {
    this.value = this.value[this.value.length - 1];
  }
  refChar.textContent = this.value;
  cachedCenterKanji = '';  // キャッシュ無効化
  drawCenterLines();
});

// ===========================
// 座標変換: 画面座標 → SVG座標
// ===========================
function getSvgPoint(e) {
  const rect = svg.getBoundingClientRect();
  const scaleX = 300 / rect.width;
  const scaleY = 300 / rect.height;
  return {
    x: (e.clientX - rect.left) * scaleX,
    y: (e.clientY - rect.top) * scaleY
  };
}

// ===========================
// ポインターイベント: タップで点配置 + ドラッグ移動
// ===========================
let tapStartPos = null;
let tapStartTime = 0;

svg.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  svg.setPointerCapture(e.pointerId);
  tapStartPos = getSvgPoint(e);
  tapStartTime = Date.now();

  // 既存の点に近いか確認 → ドラッグ開始候補
  dragIdx = -1;
  isDragging = false;
  for (let i = 0; i < tapPoints.length; i++) {
    const d = Math.hypot(tapPoints[i].x - tapStartPos.x, tapPoints[i].y - tapStartPos.y);
    if (d < 20) {
      dragIdx = i;
      break;
    }
  }

  // ドラッグ対象でなければ、スナップ先をプレビュー
  if (dragIdx < 0) {
    const snapped = applySnap({ x: Math.round(tapStartPos.x), y: Math.round(tapStartPos.y) });
    lastSnappedPos = snapped;
    showSnapCursor(snapped.x, snapped.y);
  }
});

svg.addEventListener('pointermove', (e) => {
  if (!tapStartPos) return;
  const pt = getSvgPoint(e);

  if (dragIdx >= 0) {
    // ドラッグ中: 点を移動
    isDragging = true;
    const dragPt = { x: Math.round(pt.x), y: Math.round(pt.y - 40) };
    tapPoints[dragIdx] = dragPt;
    // ドラッグ中もスナップ先をプレビュー
    const snapped = applySnap(dragPt);
    lastSnappedPos = snapped;
    showSnapCursor(snapped.x, snapped.y);
    redrawTapUI();
  } else {
    // 新規配置: スナップ先をリアルタイム更新
    const snapped = applySnap({ x: Math.round(pt.x), y: Math.round(pt.y) });
    lastSnappedPos = snapped;
    showSnapCursor(snapped.x, snapped.y);
  }
});

svg.addEventListener('pointerup', (e) => {
  hideSnapCursor();
  if (!tapStartPos) return;
  const pt = getSvgPoint(e);

  if (isDragging && dragIdx >= 0) {
    // ドラッグ終了 → プレビューで表示していた位置をそのまま使う
    if (lastSnappedPos) {
      tapPoints[dragIdx] = lastSnappedPos;
    }
    redrawTapUI();
  } else {
    // タップ判定: 移動が少なく、短時間
    const dist = Math.hypot(pt.x - tapStartPos.x, pt.y - tapStartPos.y);
    const elapsed = Date.now() - tapStartTime;
    if (dist < 15 && elapsed < 500) {
      // プレビューで表示していた位置をそのまま使う
      const newPt = lastSnappedPos || { x: Math.round(pt.x), y: Math.round(pt.y) };
      tapPoints.push(newPt);
      redrawTapUI();
      updateStrokeCount();
    }
  }
  tapStartPos = null;
  dragIdx = -1;
  isDragging = false;
  lastSnappedPos = null;
});

// タッチ制御: 1本指=タップ、2本指=スクロール＆ピンチズーム
svg.addEventListener('touchstart', e => {
  if (e.touches.length === 1) e.preventDefault();
}, { passive: false });
svg.addEventListener('touchmove', e => {
  if (e.touches.length === 1) e.preventDefault();
}, { passive: false });

// ===========================
// Catmull-Rom スプライン → SVGパス
// ===========================
function catmullRomToPath(points) {
  if (points.length < 2) return '';
  if (points.length === 2) {
    return `M ${points[0].x},${points[0].y} L ${points[1].x},${points[1].y}`;
  }

  let d = `M ${points[0].x},${points[0].y}`;
  for (let i = 0; i < points.length - 1; i++) {
    const p0 = points[Math.max(0, i - 1)];
    const p1 = points[i];
    const p2 = points[i + 1];
    const p3 = points[Math.min(points.length - 1, i + 2)];

    // Catmull-Rom → 3次ベジェの制御点
    const cp1x = p1.x + (p2.x - p0.x) / 6;
    const cp1y = p1.y + (p2.y - p0.y) / 6;
    const cp2x = p2.x - (p3.x - p1.x) / 6;
    const cp2y = p2.y - (p3.y - p1.y) / 6;

    d += ` C ${Math.round(cp1x)},${Math.round(cp1y)} ${Math.round(cp2x)},${Math.round(cp2y)} ${p2.x},${p2.y}`;
  }
  return d;
}

// ===========================
// タップUI描画
// ===========================
function redrawTapUI() {
  tapGroup.innerHTML = '';

  // 確定済みストローク
  splineStrokes.forEach((stroke, i) => {
    const color = STROKE_COLORS[i % STROKE_COLORS.length];
    const path = document.createElementNS(SVG_NS, 'path');
    path.setAttribute('d', stroke.path);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width', '10');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    tapGroup.appendChild(path);
  });

  // 現在配置中のプレビュー曲線
  const curColor = STROKE_COLORS[splineStrokes.length % STROKE_COLORS.length];
  if (tapPoints.length >= 2) {
    const previewD = catmullRomToPath(tapPoints);
    const preview = document.createElementNS(SVG_NS, 'path');
    preview.setAttribute('d', previewD);
    preview.setAttribute('fill', 'none');
    preview.setAttribute('stroke', curColor);
    preview.setAttribute('stroke-width', '10');
    preview.setAttribute('stroke-linecap', 'round');
    preview.setAttribute('stroke-linejoin', 'round');
    preview.setAttribute('stroke-opacity', '0.35');
    tapGroup.appendChild(preview);
  }

  // 配置した点（中抜き円 + 中心ドット + 番号左上）
  tapPoints.forEach((pt, i) => {
    const beingDragged = isDragging && i === dragIdx;
    const r = beingDragged ? 12 : 8;

    // 中抜き円（透明）
    const circle = document.createElementNS(SVG_NS, 'circle');
    circle.setAttribute('cx', pt.x);
    circle.setAttribute('cy', pt.y);
    circle.setAttribute('r', r);
    circle.setAttribute('fill', 'none');
    circle.setAttribute('stroke', curColor);
    circle.setAttribute('stroke-width', beingDragged ? '2.5' : '1.5');
    tapGroup.appendChild(circle);

    // 中心ドット
    const dot = document.createElementNS(SVG_NS, 'circle');
    dot.setAttribute('cx', pt.x);
    dot.setAttribute('cy', pt.y);
    dot.setAttribute('r', '2');
    dot.setAttribute('fill', curColor);
    tapGroup.appendChild(dot);

    // 番号（左上に小さく）
    const text = document.createElementNS(SVG_NS, 'text');
    text.setAttribute('x', pt.x - r - 2);
    text.setAttribute('y', pt.y - r - 1);
    text.setAttribute('text-anchor', 'end');
    text.setAttribute('font-size', '9');
    text.setAttribute('font-weight', '700');
    text.setAttribute('fill', curColor);
    text.setAttribute('pointer-events', 'none');
    text.textContent = i + 1;
    tapGroup.appendChild(text);
  });
}

// ===========================
// 画の確定・アンドゥ・全消し
// ===========================
function confirmStroke() {
  if (tapPoints.length < 2) { alert('2点以上配置してください'); return; }
  const path = catmullRomToPath(tapPoints);
  splineStrokes.push({ points: [...tapPoints], path });
  tapPoints = [];
  redrawTapUI();
  updateStrokeCount();
}

function undoPoint() {
  if (tapPoints.length === 0) return;
  tapPoints.pop();
  redrawTapUI();
  updateStrokeCount();
}

function undoStroke() {
  if (tapPoints.length > 0) {
    tapPoints = [];
  } else if (splineStrokes.length > 0) {
    // 最後の画を点に戻す（再編集可能）
    const last = splineStrokes.pop();
    tapPoints = last.points;
  }
  redrawTapUI();
  updateStrokeCount();
}

function clearAll() {
  tapPoints = [];
  splineStrokes = [];
  redrawTapUI();
  updateStrokeCount();
  document.getElementById('outputArea').style.display = 'none';
}

function updateStrokeCount() {
  const n = splineStrokes.length;
  const pts = tapPoints.length;
  if (n === 0 && pts === 0) {
    strokeCountEl.textContent = 'タップして点を配置';
  } else if (pts > 0) {
    strokeCountEl.textContent = `${n}画確定 / ${pts}点 配置中`;
  } else {
    strokeCountEl.textContent = `${n}画 入力済み`;
  }
}

// ===========================
// 中心線: Zhang-Suen 細線化で骨格抽出
// ===========================

// フォントをCanvasに直接描画してビットマップを取得（ポリゴン近似より正確）
function rasterizeFromFont(kanji, w, h) {
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.font = '600 250px "Klee One"';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';
  ctx.fillStyle = '#000';
  // Klee One メトリクス: ascent=1160, descent=288, unitsPerEm=1000
  // CSS座標系に合わせたベースライン: 25 + (-56) + 290 = 259
  ctx.fillText(kanji, w / 2, 259);
  const img = ctx.getImageData(0, 0, w, h);
  const bmp = new Uint8Array(w * h);
  for (let i = 0; i < w * h; i++) {
    bmp[i] = img.data[i * 4 + 3] > 128 ? 1 : 0;
  }
  return bmp;
}

// Zhang-Suen 細線化（ビットマップを1ピクセル幅の骨格にする）
function zhangSuenThin(bmp, w, h) {
  const g = (x, y) => (x >= 0 && x < w && y >= 0 && y < h) ? bmp[y * w + x] : 0;
  let changed = true;
  while (changed) {
    changed = false;
    for (let step = 0; step < 2; step++) {
      const rem = [];
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          if (!g(x, y)) continue;
          const n = [g(x,y-1), g(x+1,y-1), g(x+1,y), g(x+1,y+1),
                     g(x,y+1), g(x-1,y+1), g(x-1,y), g(x-1,y-1)];
          const B = n.reduce((s, v) => s + v, 0);
          if (B < 2 || B > 6) continue;
          let A = 0;
          for (let i = 0; i < 8; i++) if (n[i] === 0 && n[(i+1)%8] === 1) A++;
          if (A !== 1) continue;
          if (step === 0) {
            if (n[0]*n[2]*n[4] !== 0 || n[2]*n[4]*n[6] !== 0) continue;
          } else {
            if (n[0]*n[2]*n[6] !== 0 || n[0]*n[4]*n[6] !== 0) continue;
          }
          rem.push(y * w + x);
        }
      }
      for (const idx of rem) { bmp[idx] = 0; changed = true; }
    }
  }
}

// 骨格ピクセルを順序付きポリラインに変換
function traceSkeleton(bmp, w, h) {
  const vis = new Uint8Array(w * h);
  const g = (x, y) => (x >= 0 && x < w && y >= 0 && y < h) ? bmp[y * w + x] : 0;
  const dirs = [[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0]];
  const nCount = (x, y) => { let c=0; for (const [dx,dy] of dirs) c += g(x+dx,y+dy); return c; };

  function trace(sx, sy) {
    const chain = [{x:sx, y:sy}];
    vis[sy * w + sx] = 1;
    let cx = sx, cy = sy;
    while (true) {
      let found = false;
      for (const [dx,dy] of dirs) {
        const nx = cx+dx, ny = cy+dy;
        if (g(nx,ny) && !vis[ny*w+nx]) {
          vis[ny*w+nx] = 1;
          chain.push({x:nx, y:ny});
          cx = nx; cy = ny;
          found = true;
          break;
        }
      }
      if (!found) break;
    }
    return chain;
  }

  const polylines = [];
  // 端点（近傍1つ）から優先的にたどる
  for (let y = 0; y < h; y++)
    for (let x = 0; x < w; x++)
      if (g(x,y) && !vis[y*w+x] && nCount(x,y) === 1) {
        const c = trace(x, y);
        if (c.length >= 6) polylines.push(c);
      }
  // 残りの未訪問ピクセル（ループ等）
  for (let y = 0; y < h; y++)
    for (let x = 0; x < w; x++)
      if (g(x,y) && !vis[y*w+x]) {
        const c = trace(x, y);
        if (c.length >= 6) polylines.push(c);
      }
  return polylines;
}

// 中心線キャッシュを更新（Canvas描画 → 細線化、GLYPH_DATA不要で全漢字対応）
function ensureCenterCache() {
  const kanji = kanjiInput.value.trim();
  if (!kanji || kanji === cachedCenterKanji) return;
  cachedCenterKanji = kanji;
  cachedCenterPoints = [];
  cachedCenterLines = [];

  const W = 300, H = 300;
  const bmp = rasterizeFromFont(kanji, W, H);
  zhangSuenThin(bmp, W, H);
  const polylines = traceSkeleton(bmp, W, H);

  // ポリラインを間引き（3px間隔に簡略化）
  cachedCenterLines = polylines.map(chain => {
    const s = [chain[0]];
    for (let i = 1; i < chain.length - 1; i++) {
      const last = s[s.length - 1];
      if (Math.hypot(chain[i].x - last.x, chain[i].y - last.y) >= 3) s.push(chain[i]);
    }
    s.push(chain[chain.length - 1]);
    return s;
  });
  for (const line of cachedCenterLines) cachedCenterPoints.push(...line);
}

// 中心線を点線で描画
function drawCenterLines() {
  centerLineGroup.innerHTML = '';
  const snap = document.getElementById('centerSnap');
  if (!snap || !snap.checked) return;

  ensureCenterCache();

  for (const line of cachedCenterLines) {
    const pts = line.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
    const polyline = document.createElementNS(SVG_NS, 'polyline');
    polyline.setAttribute('points', pts);
    polyline.setAttribute('fill', 'none');
    polyline.setAttribute('stroke', '#FF8E53');
    polyline.setAttribute('stroke-width', '1.5');
    polyline.setAttribute('stroke-dasharray', '4,4');
    polyline.setAttribute('stroke-opacity', '0.6');
    centerLineGroup.appendChild(polyline);
  }
}

// 最近傍の中心点にスナップ
function applySnap(pt) {
  const snap = document.getElementById('centerSnap');
  if (!snap || !snap.checked) return pt;
  ensureCenterCache();
  if (cachedCenterPoints.length === 0) return pt;

  let best = null, bestDist = 25;
  for (const cp of cachedCenterPoints) {
    const d = Math.hypot(cp.x - pt.x, cp.y - pt.y);
    if (d < bestDist) {
      bestDist = d;
      best = cp;
    }
  }
  return best ? { x: Math.round(best.x), y: Math.round(best.y) } : pt;
}

// ===========================
// JSON出力
// ===========================
function exportJSON() {
  const kanji = kanjiInput.value.trim();
  if (!kanji) { alert('漢字を入力してください'); return; }
  if (splineStrokes.length === 0) { alert('画を確定してください'); return; }

  const data = {
    kanji,
    strokes: splineStrokes.map(s => ({
      points: s.points,
      path: s.path
    }))
  };
  const jsonStr = JSON.stringify(data, null, 2);
  const outputArea = document.getElementById('outputArea');
  const jsonOutput = document.getElementById('jsonOutput');
  jsonOutput.value = jsonStr;
  outputArea.style.display = 'block';
}

async function copyToClipboard() {
  const text = document.getElementById('jsonOutput').value;
  try {
    await navigator.clipboard.writeText(text);
    const btn = event.target;
    const orig = btn.textContent;
    btn.textContent = 'コピーしました！';
    setTimeout(() => btn.textContent = orig, 1500);
  } catch {
    document.getElementById('jsonOutput').select();
  }
}

// ===========================
// フォントから抽出した頂点データ（参照用）
// ===========================
const GLYPH_DATA = {
  '山': {
    outline: [
      [85.5,263.0],[219.8,251.5],[218.2,264.2],[218.0,266.5],
      [232.2,277.5],[236.2,271.2],[237.8,138.8],[226.8,129.5],
      [219.5,128.0],[216.8,129.8],[217.8,132.2],[220.5,146.8],
      [219.8,236.2],[157.0,241.2],[157.0,76.2],[138.2,67.2],
      [135.0,69.0],[136.2,71.8],[139.8,84.2],[140.8,242.8],
      [80.5,247.8],[80.0,145.0],[70.8,135.8],[61.8,133.8],
      [58.8,135.5],[59.8,138.0],[62.8,152.5],[64.5,237.8],
      [62.2,251.8],[61.5,255.0],[73.0,265.0]
    ]
  },
  '九': {
    outline: [
      [265.8,217.2],[265.8,212.2],[262.0,199.5],[256.8,211.5],
      [249.5,240.5],[219.5,255.2],[196.5,243.2],[197.0,235.5],
      [207.2,138.2],[208.8,130.5],[197.0,121.2],[193.2,121.5],
      [145.8,126.0],[150.8,71.2],[150.8,70.8],[131.8,59.2],
      [128.2,61.5],[128.5,62.8],[131.8,79.0],[131.8,80.5],
      [127.8,127.8],[78.8,132.2],[72.2,132.5],[59.5,131.2],
      [58.5,131.0],[57.0,132.5],[57.2,134.0],[71.2,147.5],
      [79.8,146.8],[125.0,142.8],[41.8,269.0],[36.2,275.0],
      [39.0,276.8],[129.2,190.2],[143.2,141.0],[190.2,136.8],
      [180.0,239.5],[179.8,246.0],[218.2,271.8]
    ]
  }
};

// ===========================
// フォントアウトライン表示（参照用）
// ===========================
let pointsVisible = false;
const pointsGroup = document.createElementNS(SVG_NS, 'g');
pointsGroup.id = 'glyphPoints';
pointsGroup.style.display = 'none';
pointsGroup.setAttribute('pointer-events', 'none');
svg.appendChild(pointsGroup);

function togglePoints() {
  pointsVisible = !pointsVisible;
  if (pointsVisible) {
    showGlyphOutline();
    pointsGroup.style.display = '';
  } else {
    pointsGroup.style.display = 'none';
  }
}

function showGlyphOutline() {
  pointsGroup.innerHTML = '';
  const kanji = kanjiInput.value.trim();
  const data = GLYPH_DATA[kanji];
  if (!data || !data.outline) return;

  const pts = data.outline.map(p => p.join(',')).join(' ');
  const poly = document.createElementNS(SVG_NS, 'polygon');
  poly.setAttribute('points', pts);
  poly.setAttribute('fill', '#888');
  poly.setAttribute('fill-opacity', '0.1');
  poly.setAttribute('stroke', '#aaa');
  poly.setAttribute('stroke-width', '0.5');
  pointsGroup.appendChild(poly);
}
</script>

</body>
</html>
